#include <iostream>
#include <algorithm>

//  СТРУКТУРЫ С++
struct Point {
    //  T() : f1(value1), f2(value2), ...
    //  Список инициализации - срабатывает до констркутора
    //  Поля в списке иниц. будут
    //  проинициализированны в том порядке, в котором они указаны в классе
    //
    //  Значения по умолчанию также можно указать для конструктора,
    //  что значительно увеличивает варитивность инициализации объекта
    explicit Point(double x = 0, double y = 0) : x(x), y(y) {}
    double x;
    double y;
};


struct Segment {
    Segment() {}
    //  У p1 вызовется констркутор по умолчанию (без параметров): (0,0)
    //  p2: (length, 0)
    explicit Segment(double length) : p2(length, 0)
    {}
    Point p1;
    Point p2;

private:
    //  К примеру, у этого объекте нельяза педставить операцию копирования
    //  Копир. конструктор и оператор присваивания
    //  просто объявляем с модификатором private
    Segment(Segment const& a);
    Segment& operator=(Segment const& a);

};

struct IntArray {

    //  Конструктор
    //  Запретили неявное преобразование от одного параметра
    explicit  IntArray(size_t size)
            : size_(size) , data_(new int64_t[size]), counter_(0)
    {
        for(size_t i = 0; i < size_; ++i) {
            data_[i] = 0;
        }
    }
    //  Конструктор копирования, должен быть переопределен обязательно
    //  Принимает конст. ссылку на объект, который мы хотим скопировать
    IntArray(IntArray const& a)
            : size_(a.size_), data_(new int64_t[size_]), counter_(a.counter_)
    {
        for (size_t i = 0; i < size_; ++i) {
            data_[i] = a.data_[i];
        }
    }


    //  Дестркутор - только один, и всегда без параметров
    ~IntArray() {
        delete[] data_;
    }

    void swap(IntArray& a) {
        size_t const t1 = size_;
        size_ = a.size_;
        a.size_ = t1;

        int64_t* const t2 = data_;
        data_ = a.data_;
        a.data_ = t2;
    }

    void libSwap(IntArray& a) {
        std::swap(size_, a.size_);
        std::swap(data_, a.data_);
    }

    //  Определение оператора присваивания
    //  return - ссылка на текущий объект
    //  Отличие оператора присваивания от конструктора
    //  копирования в том, что при его вызове уже существует объект,
    //  в который мы присваиваем текущий, поэтому:
    //  сначала надо удалить данные, которые уже есть в объекте
//fixme:    Определение оператора присваивания без метода swap
//    IntArray& operator=(IntArray const& a)
//    {
//        //  проверяем, не присваиваем ли мы нашему объекту этот же объект,
//        //  потому что в этом случае мы удалим данные,
//        //  которые хранятся в нашем объекте, см. ниже !!!
//        //  это легко может произойти при работе с ссылками
//        if (this != &a) {
//            delete[] data_;
//            size_ = a.size_;
//            data_ = new int64_t[size_];
//            for (size_t i = 0; i < size_; ++i) {
//                data_[i] = a.data_[i];
//            }
//        }
//        return *this;
//    }

    //  Определение оператора присваивания с методом swap и конструкт. копирования:
    IntArray& operator=(IntArray const& a) {
        if (this != &a) {
            //  Создание временной копии объекта, который мы хотим
            //  присвоить нашему объекту а затем обмен полями с
            //  нашим объектом this через swap
            //  Теперь в наш объект соотвествует копии a, а временный
            //  объект с ненужными данными  удаляется через деструктор
            //  и память освобождается
            IntArray(a).libSwap(*this);
        }
        return  *this;
    }

    void resize(size_t nsize) {
        IntArray t(nsize);   // Локальная переменная такого размера, который мы хотим
        size_t n = nsize > size_ ? size_ : nsize;
        for (size_t i = 0; i < n; ++i) {
            t.data_[i] = data_[i];   //заполнили новый объект значениями из массива
        }
        //   поменяли поля нового объекта с текущим this
        //   новый временный объект уничтожился при выходе из функции
        swap(t);
    }
    //  При попытке изменить поля объекта внутри const метода, будет error
    //  Внутри const методов можно вызывать только const меотды
    //  Если мы получили константный объект клсса (через ptr или ref),
    //  то у него можно вызвать только const методы класса
    //  все поля здесь у нас приходят как
    size_t size() const {
        counter_++;
        return size_;
    }

    int64_t& get(size_t i) {return  data_[i];}
    int64_t get(size_t i) const {return  data_[i];}
private:

    size_t size_;
    int64_t* data_;

    //  поля, который можно изменять даже из const методов
    //  не должны являться частью состояния объекта
    mutable size_t counter_;
};



int main() {

    Point p1; // x = 0, y = 0
    Point p2(3, 7); // x = 3, y = 7
    Point p3(4);     // x = 4, y = 0

    Segment s1; //  (0,0) (0,0)
    Segment s2(10); //  (0,0) (10,0)
    //  Конструкторы от одного параметра создают неявное преобразоование
    //
    //  Параметры конструктора по умолчанию также могут неявно создавать
    //  конструкторы от одного параметра, а значит и неявное преобразоование тоже
    //  fixme: Segment s3 = 20; //  (0,0) (20,0) - эквивалент. s3 = Segment(20)
    //  От такого поведения защищает ключ. слово explicit

    //  Дестрктор вызовется при выходе из блока {} где определет объект в
    //  обратном порядке вызова конструкторов
    IntArray arr1(10);
    IntArray arr2(20);

    //  выделение динамической памяти и создание объекта
    IntArray* pa = new IntArray(30);
    //  вызов деструктора и освобождение памяти
    delete pa;

    //fixme:
    //  выделение памятии создание 10 объектов
    //  (вызывается конструктор по умолчанию, который не определен для нашего объекта)
    // IntArray* parr = new IntArray[10];
    // вызова деструктора на каждом элементе массива и освобождение памяти
    // delete[] parr;

    //  PLACEMENT NEW - плохо, не делай когда не надо

    //  выделили память под IntArray
    void* ptrA =  malloc(sizeof(IntArray));

    //  создали объект по адресу ptrA
    IntArray* initPtr = new (ptrA) IntArray(10);

    //  явный вызов деструктора!
    initPtr-> ~IntArray();
    free(ptrA);



    IntArray* narr = new IntArray(5);
    for (size_t i = 0; i < narr->size(); ++i) {
        narr->get(i) = i + 1;
    }
    narr->resize(20);

    for (size_t i = 0; i < narr->size(); ++i) {
        std::cout << narr->get(i) << std::endl;
    }

    //  можем вызвать только константные методы !!!
    IntArray const* carr = new IntArray(10);
    carr = narr;
    std::cout << "size: " << carr->size() << std::endl;

    //  ЕСЛИ КОСТРУКТОР КОПИРОВАНИЯ НЕ ПЕРЕОПРЕДЕЛЕН:

    //  на стэке создали структуру - размер и указатель на массив в памяти
    IntArray a1(10);
    //  на стэке создали другую структуру - размер и указатель на массив в памяти
    IntArray a2(20);
    //  На стэке создали еще одну структуру, в поля который скопировались поля a1 - размер и указатель
    //  Теперь два объекта указывают на один и тот же массив а1.data в памяти
    IntArray a3 = a1;

    //  В поля а2 были скопированы значения полей a1 - размер и указатель на массив а1.data
    //  Теперь три объекта указывают на один и тот же массив а1.data в памяти
    a2 = a1;
    //  При выходе из функции будут вызваны дструкторы на каждом из объектов, а значит
    //  освобождение одной и той же памяти а1.data будет вызвано 3 раза, а также произойдет
    //  утечка памяти, т к память под массив a2.data не освобождена


    return 0;
}
